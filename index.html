<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HYPERION // NEXUS â€¢ OLYMPUS</title>
    <style>
        :root { --neon-cyan: #00f3ff; --glass-bg: rgba(5, 5, 5, 0.95); --olympus-gold: #ffd700; --glitch-red: #ff0055; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            background: #010102; overflow: hidden; height: 100vh; width: 100vw;
            display: flex; justify-content: center; align-items: center; 
            font-family: 'Courier New', monospace; color: white; 
        }
        
        /* --- UI & HANDHELD SHELL --- */
        #handheld { 
            position: relative; width: 380px; height: auto; max-height: 98vh;
            background: #080808; border-radius: 40px; border: 1px solid rgba(0, 243, 255, 0.2); 
            display: flex; flex-direction: column; padding: 20px; 
            box-shadow: 0 0 50px rgba(0,0,0,1); overflow: hidden;
            z-index: 10;
        }

        #screen { 
            width: 100%; aspect-ratio: 3/4; background: #000; 
            border-radius: 20px; position: relative; overflow: hidden; 
            margin-bottom: 15px; border: 1px solid #111;
        }

        canvas#mainCanvas { width: 100%; height: 100%; cursor: grab; }
        canvas#mainCanvas:active { cursor: grabbing; }

        #status-bar {
            font-size: 8px; color: var(--neon-cyan); letter-spacing: 2px;
            margin-bottom: 10px; display: flex; justify-content: space-between;
        }

        /* --- CONTROLS --- */
        #controlPanel { display: flex; flex-direction: column; gap: 8px; }
        .controls-row { display: flex; gap: 8px; }
        
        .btn { 
            flex: 1; background: var(--glass-bg); border: 1px solid #333; 
            color: var(--neon-cyan); padding: 12px 5px; border-radius: 8px; 
            font-size: 9px; font-weight: 900; cursor: pointer; 
            text-transform: uppercase; transition: 0.3s;
            text-align: center;
        }
        .btn:hover { border-color: var(--neon-cyan); background: rgba(0,243,255,0.05); }
        .btn.active { background: var(--neon-cyan); color: #000; box-shadow: 0 0 15px var(--neon-cyan); }
        
        #recordBtn { border-color: var(--glitch-red); color: var(--glitch-red); }
        #recordBtn.active { background: var(--glitch-red); color: #fff; animation: pulse 1.5s infinite; }

        input[type="file"], input[type="color"] { display: none; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .glitch-text { animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="handheld">
        <div id="status-bar">
            <span>HYPERION // ZENITH</span>
            <span id="sync-status" class="glitch-text">AWAITING CORE</span>
        </div>

        <div id="screen">
            <canvas id="mainCanvas"></canvas>
        </div>

        <div id="controlPanel">
            <div class="controls-row">
                <label for="file-upload" class="btn">LOAD CORE</label>
                <input type="file" id="file-upload" accept="audio/*">
                
                <label for="color-picker" class="btn">TINT</label>
                <input type="color" id="color-picker" value="#00f3ff">
                
                <button id="micBtn" class="btn">MIC</button>
            </div>
            
            <button id="recordBtn" class="btn">INITIALIZE RECORDING</button>
            <button id="olympusBtn" class="btn" style="border-color: var(--olympus-gold); color: var(--olympus-gold);" onclick="window.open('https://nexusvortex.ca', '_blank')">ENTER OLYMPUS</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        let audioCtx, analyser, dataArray, recorder, chunks = [];
        let bass = 0, avg = 0, treble = 0, userHue = 185;
        let isRecording = false;

        // --- SCENE SETUP ---
        const container = document.getElementById('screen');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x010103, 0.05);

        const camera = new THREE.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 12;

        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('mainCanvas'), 
            antialias: false, 
            alpha: true,
            powerPreference: "high-performance" 
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 2.0, 0.5, 0.1);
        composer.addPass(bloomPass);

        // --- SLING PHYSICS ---
        let isDragging = false, wasDragging = false;
        let rotationVelocity = { x: 0, y: 0 }, lastPos = { x: 0, y: 0 };
        let expansionFactor = 1.0, targetExpansion = 1.0;

        const onDown = (x, y) => { isDragging = true; targetExpansion = 1.4; lastPos = { x, y }; };
        const onUp = () => { isDragging = false; targetExpansion = 1.0; };
        const onMove = (x, y) => {
            if (isDragging) {
                rotationVelocity.x = (x - lastPos.x) * 0.006;
                rotationVelocity.y = (y - lastPos.y) * 0.006;
            }
            lastPos = { x, y };
        };

        renderer.domElement.addEventListener('mousedown', (e) => onDown(e.clientX, e.clientY));
        window.addEventListener('mouseup', onUp);
        window.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY));
        renderer.domElement.addEventListener('touchstart', (e) => onDown(e.touches[0].clientX, e.touches[0].clientY));
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchmove', (e) => onMove(e.touches[0].clientX, e.touches[0].clientY));

        // --- 8D CORE DATA ---
        const pointCount = 2200;
        const hyperPoints = Array.from({ length: pointCount }, () => Array.from({ length: 8 }, () => (Math.random() - 0.5) * 3.5));
        const isMalt = new Uint8Array(pointCount).map(() => Math.random() > 0.9 ? 1 : 0);

        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const swarm = new THREE.Points(geo, mat);
        scene.add(swarm);

        // --- CASCADE WEATHER ---
        const cascadeCount = 300;
        const cascadeParticles = [];
        const cGeo = new THREE.BufferGeometry();
        const cMat = new THREE.PointsMaterial({ size: 0.1, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const cSwarm = new THREE.Points(cGeo, cMat);
        scene.add(cSwarm);

        function spawnCascade(hue, speed = 1) {
            if (cascadeParticles.length < cascadeCount) {
                cascadeParticles.push({
                    x: (Math.random()-0.5)*20, y: 15, z: (Math.random()-0.5)*20,
                    vy: -0.5 * speed, life: 1.0, hue: hue
                });
            }
        }

        // --- AUDIO ENGINE ---
        function setupAudio(source) {
            if (!audioCtx) audioCtx = new AudioContext();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            source.connect(analyser);
            if (source.context.destination) source.connect(audioCtx.destination);
            document.getElementById('sync-status').innerText = "CORE_ACTIVE";
            document.getElementById('sync-status').classList.remove('glitch-text');
        }

        document.getElementById('file-upload').onchange = async (e) => {
            const audio = new Audio(URL.createObjectURL(e.target.files[0]));
            audio.play();
            setupAudio((audioCtx = new AudioContext()).createMediaElementSource(audio));
        };

        document.getElementById('micBtn').onclick = async (e) => {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            setupAudio((audioCtx = new AudioContext()).createMediaStreamSource(stream));
            e.target.classList.add('active');
        };

        document.getElementById('color-picker').oninput = (e) => {
            const hex = e.target.value;
            const r = parseInt(hex.slice(1,3), 16)/255, g = parseInt(hex.slice(3,5), 16)/255, b = parseInt(hex.slice(5,7), 16)/255;
            const max = Math.max(r,g,b), min = Math.min(r,g,b), d = max-min;
            userHue = (d === 0) ? 0 : (max === r ? (g-b)/d+(g<b?6:0) : max === g ? (b-r)/d+2 : (r-g)/d+4) * 60;
        };

        // --- RECORDING ---
        const recBtn = document.getElementById('recordBtn');
        recBtn.onclick = () => {
            if (!isRecording) {
                const stream = renderer.domElement.captureStream(60);
                recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
                    a.download = `hyperion_capture_${Date.now()}.webm`; a.click();
                    chunks = []; recBtn.innerText = "INITIALIZE RECORDING";
                };
                recorder.start(); isRecording = true; recBtn.classList.add('active'); recBtn.innerText = "STOP & EXPORT";
            } else {
                recorder.stop(); isRecording = false; recBtn.classList.remove('active');
            }
        };

        // --- MAIN LOOP ---
        let angle = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                bass = dataArray[2]/255; avg = dataArray[40]/255; treble = dataArray[100]/255;
                bloomPass.strength = 1.5 + bass * 3.0;
                if (bass > 0.5) spawnCascade(userHue, 1.5);
            }

            // Inertia & Sling
            if (!isDragging) {
                rotationVelocity.x *= 0.95; rotationVelocity.y *= 0.95;
                expansionFactor += (targetExpansion - expansionFactor) * 0.1;
                if (wasDragging && Math.abs(rotationVelocity.x) > 0.01) spawnCascade(userHue, 3);
            } else { expansionFactor += (targetExpansion - expansionFactor) * 0.2; }
            wasDragging = isDragging;

            swarm.rotation.y += rotationVelocity.x;
            swarm.rotation.x += rotationVelocity.y;
            angle += 0.005 + (avg * 0.05);

            // Update Swarm
            const pA = new Float32Array(pointCount * 3), cA = new Float32Array(pointCount * 3);
            hyperPoints.forEach((p, i) => {
                let c = [...p], r = angle * (1 + (i%2 ? bass : avg));
                let tX = c[0]*Math.cos(r) - c[1]*Math.sin(r); c[1] = c[0]*Math.sin(r) + c[1]*Math.cos(r); c[0] = tX;
                const d = (Math.abs(c[5]) * 0.5 + 0.5) * expansionFactor;
                pA[i*3] = c[0]*4*d; pA[i*3+1] = c[2]*4*d; pA[i*3+2] = c[4]*4*d;
                const rgb = hslToRgb(((userHue + (isMalt[i]?40:0) + bass*20)%360)/360, 0.9, 0.7);
                cA[i*3]=rgb[0]; cA[i*3+1]=rgb[1]; cA[i*3+2]=rgb[2];
            });
            geo.setAttribute('position', new THREE.BufferAttribute(pA, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cA, 3));

            // Update Cascade
            const cpA = new Float32Array(cascadeCount*3), ccA = new Float32Array(cascadeCount*3);
            cascadeParticles.forEach((p, i) => {
                p.y += p.vy; p.life -= 0.01;
                if(p.life <= 0) cascadeParticles.splice(i,1);
                const idx = i*3; cpA[idx]=p.x; cpA[idx+1]=p.y; cpA[idx+2]=p.z;
                const rgb = hslToRgb(p.hue/360, 1, 0.8);
                ccA[idx]=rgb[0]*p.life; ccA[idx+1]=rgb[1]*p.life; ccA[idx+2]=rgb[2]*p.life;
            });
            cGeo.setAttribute('position', new THREE.BufferAttribute(cpA, 3));
            cGeo.setAttribute('color', new THREE.BufferAttribute(ccA, 3));

            controls.update();
            composer.render();
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
            const f = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            return [f(p, q, h + 1/3), f(p, q, h), f(p, q, h - 1/3)];
        }

        animate();
    </script>
</body>
</html>
