<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HYPERION // ZENITH_MASTER</title>
    <style>
        :root { --neon: #00f3ff; --glass: rgba(0, 0, 0, 0.55); --pink: #ff0055; }
        * { box-sizing: border-box; margin: 0; padding: 0; touch-action: none; }
        
        body { 
            background: #000; overflow: hidden; height: 100vh; width: 100vw; 
            font-family: 'Courier New', monospace; 
        }

        canvas#mainCanvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: auto;
        }

        #shade-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.65); z-index: 5; pointer-events: none;
        }

        #media-deck {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; display: flex; justify-content: center; align-items: center;
            pointer-events: none;
        }
        
        video#bg-video, img#bg-image {
            max-width: 90%; max-height: 80%;
            box-shadow: 0 0 70px rgba(0, 243, 255, 0.25);
            border-radius: 10px; display: none;
            animation: breathe 8s ease-in-out infinite;
            border: 1px solid rgba(0, 243, 255, 0.1);
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.95; }
            50% { transform: scale(1.02); opacity: 1; }
        }

        #ui {
            position: absolute; top: 25px; left: 25px; z-index: 100;
            color: var(--neon); font-size: 10px; letter-spacing: 2px;
            pointer-events: none; text-shadow: 0 0 10px var(--neon);
        }

        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 520px; z-index: 100;
            background: var(--glass); padding: 16px; border-radius: 14px;
            border: 1px solid rgba(0, 243, 255, 0.35); backdrop-filter: blur(15px);
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }

        .btn, .color-container {
            background: rgba(10, 10, 10, 0.8); border: 1px solid rgba(0, 243, 255, 0.4);
            color: var(--neon); padding: 13px; border-radius: 8px;
            cursor: pointer; text-transform: uppercase; font-size: 9px; font-weight: 800;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        
        input { display: none; }
        .color-preview { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #fff; }
        .glitch { color: var(--pink); animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <canvas id="mainCanvas"></canvas>
    <div id="shade-overlay"></div>

    <div id="media-deck">
        <video id="bg-video" playsinline loop muted autoplay></video>
        <img id="bg-image" alt="Core Memory">
    </div>

    <div id="ui">
        // HYPERION // ZENITH_MASTER<br>
        // STATUS: <span id="sync-status" class="glitch">AWAITING CORE</span><br>
        // ARCH: MEDIA_FLOAT_INVERSE_8D
    </div>

    <div id="controls">
        <label for="visual-upload" class="btn">LOAD VISUAL CORE</label>
        <input type="file" id="visual-upload" accept="video/*,image/*">
        
        <label for="audio-upload" class="btn">LOAD AUDIO CORE</label>
        <input type="file" id="audio-upload" accept="audio/*">

        <label for="color-picker" class="color-container">
            SPECTRUM <div id="preview" class="color-preview" style="background:#00f3ff"></div>
        </label>
        <input type="color" id="color-picker" value="#00f3ff">

        <div id="mic-btn" class="btn">MIC SYNC</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        let audioCtx, analyser, dataArray;
        let bass = 0, avg = 0, treble = 0;
        let globalHue = 190;

        const vid = document.getElementById('bg-video');
        const img = document.getElementById('bg-image');

        document.getElementById('visual-upload').onchange = (e) => {
            const file = e.target.files[0];
            const url = URL.createObjectURL(file);
            if (file.type.startsWith('video')) {
                img.style.display = 'none'; vid.style.display = 'block';
                vid.src = url; vid.muted = true; vid.play();
            } else {
                vid.style.display = 'none'; img.style.display = 'block';
                img.src = url;
            }
        };

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x010103, 0.055);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 13;

        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('mainCanvas'), 
            antialias: true, alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.6, 0.15);
        composer.addPass(bloom);

        // === ORIGINAL 8D HYPER-SWARM CORE ===
        const pointCount = 1800;
        const hyperPoints = [];
        const isMagentaArray = new Uint8Array(pointCount);
        for (let i = 0; i < pointCount; i++) {
            hyperPoints.push(Array.from({length: 8}, () => (Math.random() - 0.5) * 3));
            isMagentaArray[i] = Math.random() > 0.88 ? 1 : 0;
        }

        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({ size: 0.045, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.95 });
        const swarm = new THREE.Points(geometry, material);
        scene.add(swarm);

        // === CASCADE ENGINE (spectrum-triggered rain) ===
        const cascadeCount = 400;
        const cascadePositions = new Float32Array(cascadeCount * 3);
        const cascadeColors = new Float32Array(cascadeCount * 3);
        const cascadeGeo = new THREE.BufferGeometry();
        const cascadeMat = new THREE.PointsMaterial({ size: 0.08, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const cascadeMesh = new THREE.Points(cascadeGeo, cascadeMat);
        scene.add(cascadeMesh);
        let cascadeParticles = [];

        function spawnCascade(count, baseHue, speedMod = 1) {
            for (let i = 0; i < count; i++) {
                if (cascadeParticles.length >= cascadeCount) break;
                const hue = (baseHue + (Math.random() * 40 - 20)) % 360;
                cascadeParticles.push({
                    x: (Math.random() - 0.5) * 25,
                    y: 15 + Math.random() * 8,
                    z: (Math.random() - 0.5) * 25,
                    vx: (Math.random() - 0.5) * 0.08,
                    vy: -0.85 - Math.random() * speedMod,
                    vz: (Math.random() - 0.5) * 0.08,
                    life: 1.0,
                    hue
                });
            }
        }

        // === AUDIO ENGINE ===
        async function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 512;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        document.getElementById('audio-upload').onchange = async (e) => {
            await initAudio();
            const audio = new Audio(URL.createObjectURL(e.target.files[0]));
            await audio.play();
            const src = audioCtx.createMediaElementSource(audio);
            src.connect(analyser);
            src.connect(audioCtx.destination);
            document.getElementById('sync-status').innerText = "AUDIO_FORGE_ACTIVE";
            document.getElementById('sync-status').classList.remove('glitch');
        };

        document.getElementById('mic-btn').onclick = async () => {
            await initAudio();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioCtx.createMediaStreamSource(stream).connect(analyser);
            document.getElementById('sync-status').innerText = "MIC_LIVE";
            document.getElementById('sync-status').classList.remove('glitch');
        };

        // === SPECTRUM COLOR CONTROL ===
        document.getElementById('color-picker').oninput = (e) => {
            document.getElementById('preview').style.background = e.target.value;
            const hex = e.target.value;
            const r = parseInt(hex.slice(1,3), 16);
            globalHue = (r / 255) * 360; // simple but effective base hue mapping
        };

        let angle = 0;

        function animate() {
            requestAnimationFrame(animate);

            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                bass   = dataArray.slice(0, 10).reduce((a,b)=>a+b,0) / (10*255);
                avg    = dataArray.reduce((a,b)=>a+b,0) / (dataArray.length*255);
                treble = dataArray.slice(200, 250).reduce((a,b)=>a+b,0) / (50*255);

                bloom.strength  = 2.0 + bass * 3.5;
                bloom.radius    = 0.6 + bass * 0.5;
                bloom.threshold = 0.15 - avg * 0.12;

                // Cascade rain â€” full spectrum response
                if (bass   > 0.42) spawnCascade(12 + Math.floor(bass*20),   30, 0.7);   // warm embers
                if (avg    > 0.32) spawnCascade(8 + Math.floor(avg*14),   195, 1.1);   // cyan mist
                if (treble > 0.35) spawnCascade(20 + Math.floor(treble*26), 310, 1.9); // magenta sparks
            }

            angle += 0.0038 + (avg * 0.07);

            // === FULL 8D ROTATION MATH (restored original logic) ===
            const pos = new Float32Array(pointCount * 3);
            const col = new Float32Array(pointCount * 3);

            hyperPoints.forEach((p, i) => {
                let c = [...p];

                // Bass warps primary plane (0-1)
                let rB = angle * (1 + bass * 1.8);
                let t = c[0] * Math.cos(rB) - c[1] * Math.sin(rB);
                c[1] = c[0] * Math.sin(rB) + c[1] * Math.cos(rB);
                c[0] = t;

                // Mids twist secondary plane (2-3)
                let rM = angle * 1.4 * (1 + avg * 1.2);
                t = c[2] * Math.cos(rM) - c[3] * Math.sin(rM);
                c[3] = c[2] * Math.sin(rM) + c[3] * Math.cos(rM);
                c[2] = t;

                // Treble punctures deep plane (4-7)
                let rH = angle * 0.7 * (1 + treble * 3.0);
                t = c[4] * Math.cos(rH) - c[7] * Math.sin(rH);
                c[7] = c[4] * Math.sin(rH) + c[7] * Math.cos(rH);
                c[4] = t;

                // Depth squash using hidden dimension
                const df = Math.abs(c[5]) * 0.42 + 0.58;

                pos[i*3]   = c[0] * 4.2 * df;
                pos[i*3+1] = c[2] * 4.2 * df;
                pos[i*3+2] = c[4] * 4.2 * df;

                const pulse = Math.sin(angle * 3.5 + c[0]) * 0.5 + 0.5;
                const h = (globalHue + (isMagentaArray[i] ? 60 : 0)) % 360;
                const rgb = hslToRgb(h / 360, 0.95, 0.78);

                col[i*3]   = isMagentaArray[i] ? (0.65 + bass + treble * 0.55) * pulse : rgb[0];
                col[i*3+1] = isMagentaArray[i] ? 0 : rgb[1] * (1 - pulse * 0.22);
                col[i*3+2] = rgb[2];
            });

            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));

            // Cascade update
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx; p.y += p.vy; p.z += p.vz;
                p.vy -= 0.014; p.life -= 0.019;
                if (p.life <= 0) particles.splice(i, 1);
            }

            for (let i = 0; i < cascadeCount; i++) {
                let idx = i * 3;
                if (i < particles.length) {
                    let p = particles[i];
                    cPositions[idx] = p.x; cPositions[idx+1] = p.y; cPositions[idx+2] = p.z;
                    let rgb = hslToRgb(p.h / 360, 1, 0.85);
                    cColors[idx] = rgb[0] * p.life; cColors[idx+1] = rgb[1] * p.life; cColors[idx+2] = rgb[2] * p.life;
                } else {
                    cPositions[idx] = 1000;
                }
            }
            cGeo.setAttribute('position', new THREE.BufferAttribute(cPositions, 3));
            cGeo.setAttribute('color', new THREE.BufferAttribute(cColors, 3));

            composer.render();
        }

        function hslToRgb(h, s, l) {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            const f = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            return [f(p, q, h + 1/3), f(p, q, h), f(p, q, h - 1/3)];
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
