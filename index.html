<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KRONOS // HYPERION GRAVITAS</title>
    <style>
        :root { --neon: #00f3ff; --glass: rgba(0, 0, 0, 0.6); --pink: #ff0055; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { background: #000; overflow: hidden; height: 100vh; width: 100vw; font-family: 'Courier New', monospace; }
        
        #video-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -2; background: #000; }
        video#bg-video { position: absolute; top: 50%; left: 50%; min-width: 100%; min-height: 100%; width: auto; height: auto; transform: translate(-50%, -50%); object-fit: cover; opacity: 1; transition: opacity 2s; }
        #dimmer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.3); z-index: -1; }

        canvas#mainCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; cursor: crosshair; }

        #hud { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 600px; z-index: 100; display: flex; flex-direction: column; gap: 10px;
            background: var(--glass); padding: 20px; border-radius: 15px; border: 1px solid rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        }

        .row { display: flex; gap: 8px; }
        .btn { 
            flex: 1; background: rgba(0, 243, 255, 0.05); border: 1px solid rgba(0, 243, 255, 0.3); 
            color: var(--neon); padding: 12px 2px; border-radius: 8px; font-size: 8px; font-weight: 900; 
            cursor: pointer; text-transform: uppercase; text-align: center; letter-spacing: 1px;
        }
        .btn.active { background: var(--neon); color: #000; box-shadow: 0 0 15px var(--neon); }
        input { display: none; }
        #status { font-size: 9px; color: var(--neon); text-align: left; letter-spacing: 2px; margin-bottom: 5px; text-shadow: 0 0 5px var(--neon); }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="bg-video" playsinline loop muted autoplay 
               src="https://assets.mixkit.co/videos/preview/mixkit-abstract-technology-loop-with-blue-lights-40244-large.mp4">
        </video>
        <div id="dimmer"></div>
    </div>

    <canvas id="mainCanvas"></canvas>

    <div id="hud">
        <div id="status">// KRONOS ENGINE: GRAVITAS_SLING_ACTIVE</div>
        <div class="row">
            <label for="vid-up" class="btn">LOAD MEMORY</label>
            <input type="file" id="vid-up">
            
            <label for="aud-up" class="btn">SONIC CORE</label>
            <input type="file" id="aud-up">
            
            <button id="vortBtn" class="btn">VORTEX: OFF</button>
        </div>
        <div class="row">
            <label for="color-picker" class="btn" id="tint-label">CORE_TINT</label>
            <input type="color" id="color-picker" value="#00f3ff">
            
            <button id="micBtn" class="btn">MIC SYNC</button>
            <button id="recordBtn" class="btn" style="color: var(--pink); border-color: var(--pink);">CAPTURE</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        let audioCtx, analyser, dataArray, prioritySource = null;
        let bass = 0, avg = 0, treble = 0, userHue = 185;
        let isVortex = false, isDragging = false, expansion = 1.0;
        let rotVel = { x: 0, y: 0 }, lastMouse = { x: 0, y: 0 };

        const video = document.getElementById('bg-video');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 12;

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('mainCanvas'), antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.6, 0.1);
        composer.addPass(bloom);

        // --- SWARM DATA ---
        const pCount = 2000;
        const hPoints = Array.from({ length: pCount }, () => Array.from({ length: 8 }, () => (Math.random() - 0.5) * 4.5));
        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const swarm = new THREE.Points(geo, mat);
        scene.add(swarm);

        // --- CASCADE DATA ---
        const cCount = 400;
        const cParticles = [];
        const cGeo = new THREE.BufferGeometry();
        const cMat = new THREE.PointsMaterial({ size: 0.09, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const cMesh = new THREE.Points(cGeo, cMat);
        scene.add(cMesh);

        function spawnCascade() {
            if (cParticles.length < cCount) {
                cParticles.push({
                    x: (Math.random() - 0.5) * 25, y: 15, z: (Math.random() - 0.5) * 20,
                    vy: -0.5 - Math.random() * 0.5, life: 1.0, hue: (userHue + (Math.random()*20-10))
                });
            }
        }

        // --- INTERACTION ---
        const onDown = (x, y) => { isDragging = true; lastMouse = { x, y }; };
        const onUp = () => isDragging = false;
        const onMove = (x, y) => {
            if (isDragging) {
                rotVel.x = (x - lastMouse.x) * 0.005;
                rotVel.y = (y - lastMouse.y) * 0.005;
            }
            lastMouse = { x, y };
        };
        window.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
        window.addEventListener('mouseup', onUp);
        window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));

        // --- AUDIO ---
        function setupAudio(source, label) {
            if (!audioCtx) audioCtx = new AudioContext();
            if (!analyser) { analyser = audioCtx.createAnalyser(); analyser.fftSize = 512; dataArray = new Uint8Array(analyser.frequencyBinCount); }
            if (prioritySource) prioritySource.disconnect();
            source.connect(analyser); prioritySource = source;
            document.getElementById('status').innerText = `// ENGINE: ${label}_SYNC_ACTIVE`;
        }

        document.getElementById('vid-up').onchange = (e) => {
            video.src = URL.createObjectURL(e.target.files[0]);
            video.play();
            const source = (audioCtx || new AudioContext()).createMediaElementSource(video);
            source.connect((audioCtx || new AudioContext()).destination);
            if (!prioritySource) setupAudio(source, "MEMORY");
        };

        document.getElementById('aud-up').onchange = (e) => {
            const audio = new Audio(URL.createObjectURL(e.target.files[0]));
            audio.play();
            const source = (audioCtx || new AudioContext()).createMediaElementSource(audio);
            source.connect((audioCtx || new AudioContext()).destination);
            setupAudio(source, "SONIC_CORE");
        };

        document.getElementById('color-picker').oninput = (e) => {
            const hex = e.target.value;
            const r = parseInt(hex.slice(1,3), 16) / 255;
            const g = parseInt(hex.slice(3,5), 16) / 255;
            const b = parseInt(hex.slice(5,7), 16) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = (max === min) ? 0 : (max === r) ? (g-b)/(max-min) : (max === g) ? 2+(b-r)/(max-min) : 4+(r-g)/(max-min);
            userHue = h * 60;
            document.getElementById('status').style.color = hex;
        };

        document.getElementById('vortBtn').onclick = (e) => { isVortex = !isVortex; e.target.classList.toggle('active'); };

        function animate() {
            requestAnimationFrame(animate);
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                bass = dataArray[2]/255; avg = dataArray[128]/255; treble = dataArray[240]/255;
                bloom.strength = 1.5 + bass * 3.0;
                if (bass > 0.6) spawnCascade();
            }

            expansion += ( (isDragging ? 1.5 : 1.0) - expansion) * 0.1;
            swarm.rotation.y += rotVel.x + 0.002;
            swarm.rotation.x += rotVel.y;
            rotVel.x *= 0.95; rotVel.y *= 0.95;

            const posA = new Float32Array(pCount * 3);
            const colA = new Float32Array(pCount * 3);

            hPoints.forEach((p, i) => {
                let r = performance.now() * 0.0008 * (1 + (i%2 ? bass : avg));
                let x = p[0] * Math.cos(r) - p[1] * Math.sin(r);
                let y = p[0] * Math.sin(r) + p[1] * Math.cos(r);
                let z = p[2] * Math.cos(r*0.5);

                if (isVortex) {
                    let d = Math.sqrt(x*x + y*y);
                    let angle = (bass * 3.5 - treble * 1.5) * (1.2 / (d + 0.5));
                    let vx = x * Math.cos(angle) - y * Math.sin(angle);
                    y = x * Math.sin(angle) + y * Math.cos(angle);
                    x = vx;
                }

                const s = (Math.abs(p[5]) * 0.5 + 0.5) * expansion;
                posA[i*3] = x * 4 * s; posA[i*3+1] = y * 4 * s; posA[i*3+2] = z * 4 * s;
                
                const rgb = hslToRgb(((userHue + bass*30)%360)/360, 0.8, 0.7);
                colA[i*3] = rgb[0]; colA[i*3+1] = rgb[1]; colA[i*3+2] = rgb[2];
            });

            geo.setAttribute('position', new THREE.BufferAttribute(posA, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colA, 3));

            // --- CASCADE RENDER ---
            const cPos = new Float32Array(cCount * 3);
            const cCol = new Float32Array(cCount * 3);
            cParticles.forEach((p, i) => {
                p.y += p.vy; p.life -= 0.01;
                if (p.life <= 0) { cParticles.splice(i, 1); return; }
                cPos[i*3] = p.x; cPos[i*3+1] = p.y; cPos[i*3+2] = p.z;
                const rgb = hslToRgb((p.hue%360)/360, 1, 0.8);
                cCol[i*3] = rgb[0]*p.life; cCol[i*3+1] = rgb[1]*p.life; cCol[i*3+2] = rgb[2]*p.life;
            });
            cGeo.setAttribute('position', new THREE.BufferAttribute(cPos, 3));
            cGeo.setAttribute('color', new THREE.BufferAttribute(cCol, 3));

            composer.render();
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
            const f = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            return [f(p, q, h + 1/3), f(p, q, h), f(p, q, h - 1/3)];
        }
        animate();
    </script>
</body>
</html>
